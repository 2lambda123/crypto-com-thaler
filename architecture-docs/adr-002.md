# ADR 002: Finalize specifications for interaction between Validator Set Changes, Punishments and Rewards

## Changelog
- 23-01-2020: Initial Draft

## Context

Currently, `ValidatorState` is used by punishments and rewards as a source of data to compute their respective slashing
ratio and rewards amount. Besides this, `ValidatorState` is also used to manage dynamic validator set (i.e.,
validators can be added or removed based on their network operations).

### Problems with current design

1. Our current design does not delete validator information from `ValidatorState` when a validator either unbonds their
   funds or gets removed from validator set because of some punishment. The reason for not deleting this information is
   because it is still required for computing `SlashRatio` while slashing a punished validator. Because of this,
   validators cannot rejoin validator set (because their information already exists and we cannot add a duplicate
   entry).
1. During rewards calculation, we calculate `total_stake` based of the active validator at the time of rewards
   distribution. This does not take into account all the validator set changes that took place in current rewards
   period. For example, when a validator unbonds or deposits funds just before rewards distribution (let us assume that
   they unbonded their funds at 23rd hour), their stake is not considered in rewards calculation.

Besides this, validator set, rewards pool and punishments are three different components of our system and should
maintain their own data instead of relying on `ValidatorState` for information. There should be a specified
interface/behavior for interaction between these components.

## Decision

This document proposes new design for Dynamic Validator Set, Punishments and Rewards Pool. At the end, it specifies the
interaction between all three components. 

### Dynamic Validator Set

`Validator` struct holds all the information related to a validator/council node.

```rust
/// A validator in Crypto.com Chain (this data structure can be merged with existing `CouncilNode`)
pub struct Validator {
    /// Name of validator
    pub name: String,
    /// Staking address of validator's staking account
    pub staking_address: StakedStateAddress,
    /// Tendermint's public key of validator
    pub tendermint_pub_key: TendermintPubKey,
    /// Current voting power of validator
    pub voting_power: TendermintVotePower,
    /// Optional security contact information
    pub security_contact: Option<String>,
}
```

Current validator set is maintained by `ValidatorState` struct. It exposes functions to add, remove and update current
validator set. Besides this, `ValidatorState` also exposes function to calculate total voting power of current validator
set which is used to calculate slash ratio while slashing a validator.

```rust
/// Runtime state of validator set
pub struct ValidatorState {
    /// All the validators corresponding to their staking address
    validators: BTreeMap<StakedStateAddress, Validator>,
    /// Staking address of validators based on their tendermint validator address (can be used to find validator
    /// information from tendermint validator address)
    tendermint_addresses: BTreeMap<TendermintValidatorAddress, StakedStateAddress>,
}

impl ValidatorState {
    /// Calculates the total voting power of current active validators (used to calculate slash ratio)
    pub fn get_total_voting_power(&self) -> TendermintVotePower {
        todo!()
    }

    /// Retrieves details of a validator with given staking address (we can filter out inactive validators if required)
    pub fn get_validator(&self, address: StakedStateAddress) -> Option<&Validator> {
        todo!()
    }

    /// Adds a validator to validator set
    ///
    /// # Note
    ///
    /// - Returns `Err` when a validator with `staking_address` already exists
    /// - Returns `Err` when validator's `voting_power` is set to zero
    pub fn add_validator(&mut self, validator: Validator) -> Result<()> {
        todo!()
    }

    /// Removes a validator from validator set
    ///
    /// # Note
    ///
    /// - Returns `Err` when validator with given address does not exist
    pub fn remove_validator(&mut self, address: StakedStateAddress) -> Result<Validator> {
        todo!()
    }

    /// Retrieves a mutable reference to validator details of given staking address (this can be used to modify an
    /// existing validator's voting power when they unbond or deposit)
    ///
    /// # Note
    ///
    /// - Removes validator when `new_voting_power` is zero
    /// - Returns `Err` when validator does not exist
    pub fn update_voting_power(
        &mut self,
        address: &StakedStateAddress,
        new_voting_power: TendermintVotePower,
    ) -> Result<()> {
        todo!()
    }

    /// Returns a list of active validators in descending order of their voting power
    ///
    /// # Note
    ///
    /// Sorts the list of validators in descending order of their voting power and returns top `max_validators`.
    /// Implementation can be optimized so that we don't have to perform sort every time.
    pub fn get_active_validators(&self) -> Vec<Validator> {
        todo!()
    }
}
```

### Validator Punishments (Jailing and Slashing)

`LivenessTracker` is used to track liveness of all the current active validators. A the beginning of each block,
liveness of each active validator is updated using `update_liveness` function. Besides this, `LivenessTracker` also
exposes function to add and remove a validator from liveness tracking. Finally, `is_live` function can be used to check
if a given validator is live or not.

```rust
/// Liveness tracker for validators
pub struct LivenessTracker {
    /// Number of blocks to use for calculating validator liveness (jailing parameter in genesis)
    block_signing_window: u16,
    /// Number of blocks a validator can miss signing from last `block_signing_window` blocks
    missed_block_threshold: u16,
    /// Holds data to measure liveness of a validator
    ///
    /// # Note
    ///
    /// - Size of this `BitVec` should be equal to `block_signing_window`.
    /// - Stores `true` at `index = height % block_signing_window`, if validator has signed that block, `false`
    ///   otherwise.
    liveness: BTreeMap<TendermintValidatorAddress, BitVec>,
}

impl LivenessTracker {
    /// Adds a validator to liveness tracking
    ///
    /// # Note
    ///
    /// - Returns `Err` when a validator with `tendermint_validator_address` already exists
    pub fn add_validator(&mut self, tendermint_validator_address: TendermintValidatorAddress) -> Result<()> {
        todo!()
    }

    /// Removes validator from liveness tracking
    ///
    /// # Note
    ///
    /// - Returns `Err` when validator with given address does not exist
    pub fn remove_validator(
        &mut self, 
        tendermint_validator_address: &TendermintValidatorAddress,
    ) -> Result<Validator> {
        todo!()
    }

    /// Updates liveness of a validator with new block data
    ///
    /// # Note
    ///
    /// - Returns `Err` when validator with given address does not exist
    pub fn update_liveness(
        &mut self, 
        tendermint_validator_address: &TendermintValidatorAddress,
        lock_height: BlockHeight,
        signed: bool,
    ) -> Result<()> {
        todo!()
    }

    /// Checks if a validator is live or not
    ///
    /// # Note
    ///
    /// - Returns `Err` when validator with given address does not exist
    pub fn is_live(&self, tendermint_validator_address, &TendermintValidatorAddress) -> Result<bool> {
        todo!()
    }
}
```

`SlashingSchedule` holds the slashing related information of a validator when they are punished. It exposes two
functions, `update_slash_ratio` and `can_slash`. `update_slash_ratio` is used to update slash ratio of a validator when
they make multiple faults. `can_slash` is used to check if the validator can be slashed at given time. 

```rust
/// Slashing schedule for a staking account
pub struct SlashingSchedule {
    /// Slash ratio for an account
    pub slash_ratio: SlashRatio,
    /// Time after which slashing can be performed
    pub slashing_time: Timespec,
    /// Kind of punishment for which the account is scheduled to be slashed
    pub punishment_kind: PunishmentKind,
    /// Voting power of validator at the time of punishment
    pub voting_power: TendermintVotePower,
}

impl SlashingSchedule {
    /// Updates slash ratio (only if proposed ratio is greater than current)
    pub fn update_slash_ratio(&mut self, new_ratio: SlashRatio, punishment_kind: PunishmentKind) {
        if new_ratio > self.slash_ratio {
            self.slash_ratio = new_ratio;
            self.punishment_kind = punishment_kind;
        }
    }

    /// Returns true if account can be slashed at a given time
    pub fn can_slash(&self, current_time: Timespec) -> bool {
        current_time >= self.slashing_time
    }
}
```

`SlashingQueue` maintains a queue of slashing schedules of all the punished validators. It exposes functions to add,
remove and update slashing schedules of punished validators. It also exposes `can_slash` function to check if any
validator can be slashed at given time.

```rust
pub struct SlashingQueue {
    /// Slashing queue for accounts that are scheduled to be slashed
    schedule: BTreeMap<StakedStateAddress, SlashingSchedule>,
}

impl SlashingQueue {
    /// Adds a slashing schedule to current slashing queue. If given account was already slashed, it updates the
    /// `slash_ratio` of existing schedule
    ///
    /// # Note
    ///
    /// - Returns `Err` when a validator with `staking_address` already exists
    pub fn add_schedule(&mut self, staking_address: StakedStateAddress, schedule: SlashingSchedule) -> Result<()> {
        todo!()
    }

    /// Removes a slashing schedule from current slashing queue
    ///
    /// # Note
    ///
    /// - Returns `Err` when validator with given address does not exist
    pub fn remove_schedule(&mut self, staking_address: &StakedStateAddress) -> Result<SlashingSchedule> {
        todo!()
    }

    /// Updates slash ratio of validator corresponding to given staking address
    ///
    /// # Note
    ///
    /// - Returns `Err` when validator with given address does not exist
    pub fn update_slash_ratio(
        &mut self, 
        staking_address: &StakedStateAddress, 
        new_ratio: SlashRatio,
        punishment_kind: PunishmentKind,
    ) -> Result<()> {
        todo!()
    }

    /// Returns true if validator corresponding to given staking address can be slashed at a given time
    ///
    /// # Note
    ///
    /// - Returns `Err` when validator with given address does not exist
    pub fn can_slash(&self, staking_address: &StakedStateAddress, current_time: Timespec) -> Result<bool> {
        todo!()
    }
}
```

Finally, `ValidatorPunishment` is a wrapper struct to hold `LivenssTracker` and `SlashingQueue`.

```rust
pub struct ValidatorPunishment {
    /// Liveness tracker for validators
    pub liveness_tracker: LivenessTracker,
    /// Slashing queue for accounts that are scheduled to be slashed
    pub slashing_queue: SlashingQueue,
}
```

### Validator Rewards

`RewardConfig` struct is used to hold all the reward related configuration provided in `genesis.json` and modify the 
variables (`tau`) as the rewards are distributed. It exposes functions to calculate reward and also to update `tau`
after rewards are distributed.

```rust
/// Configuration for computing and distributing rewards to validators
pub struct RewardConfig {
    /// Rewards pool cap (`monetary_expansion_cap`)
    cap: Coin,
    /// Upper bound for reward distribution rate (`monetary_expansion_r0`)
    r0: FixedNumber,
    /// Tau (`monetary_expansion_tau`)
    tau: FixedNumber,
    /// Decay factor for tau (`monetary_expansion_decay`)
    decay_factor: u32,
    /// Period after which rewards are distributed (`distribution_period` in secs)
    distribution_period: u32,
}

impl RewardConfig {
    /// Calculates reward for given values
    pub fn calculate_reward(&self, sum_average_stake: Coin, minted: Coin) -> Coin {
        todo!()
    }

    /// Decays `tau` based on `decay_factor`
    pub fn decay_tau(&mut self) {
        todo!()
    }
}
```

`RewardsPoolState` struct tracks already distributed rewards and calculates rewards during distribution.

```rust
/// Tracks and computes rewards for validators
pub struct RewardPoolState {
    /// Reward configuration (from genesis)
    pub config: RewardConfig,
    /// Rewards accumulated in current period
    pub period_bonus: Coin,
    /// last block height that updated it (i64 from Tendermint protobuf)
    pub last_block_height: BlockHeight,
    /// last reward distribution time
    pub last_distribution_time: Timespec,
    /// Record how many coins have been minted, can't exceed the cap
    pub minted: Coin,
}

impl RewardPoolState {
    /// Calculates reward for given `sum_average_stake`
    ///
    /// # Note
    ///
    /// `sum_average_stake` can be calculated using `ProposerTracker::get_sum_average_stake()`
    #[inline]
    pub fn calculate_reward(&self, sum_average_stake: Coin) -> Coin {
        self.config.calculate_reward(total_stake, self.minted)
    }

    /// Decays `tau` based on `decay_factor` in rewards config
    #[inline]
    pub fn decay_tau(&mut self) {
        self.config.decay_tau()
    }

    /// Updates rewards pool state with given values
    pub fn update(
        &mut self, 
        period_bonus: Coin, 
        last_block_height: BlockHeight, 
        last_distribution_time: Timespec, 
        minted: Coin,
    ) {
        self.period_bonus = period_bonus;
        self.last_block_height = last_block_height;
        self.last_distribution_time = last_distribution_time;
        self.minted = minted;
    }
}
```

`ProposerTracker` tracks the number of blocks proposed by any validator and also maintains all the validator set changes
in current reward period.

```rust
/// Tracks the number of blocks proposed by validators and also their voting power changes
pub struct ProposerTracker {
    /// Number of blocks a validator proposed in current reward period
    proposer_count: BTreeMap<StakedStateAddress, u64>,
    /// Changes in active validator set in current reward period
    validator_set_changes: Vec<(Timespec, Vec<Validator>)>,
}

impl ProposerTracker {
    /// Initializes a new rewards period
    #[inline]
    pub initialize(&mut self, time: Timespec, active_validator_set: Vec<Validator>) {
        self.clear();
        self.initial_voting_powers = vec![(time, active_validator_set)];
    }

    /// Clears proposer history (should be called when rewards are distributed)
    #[inline]
    pub fn clear() {
        self.proposer_count.clear();
        self.validator_set_changes.clear();
    }

    /// Adds given staking address to proposed count
    #[inline]
    pub fn proposed(&mut self, staking_address: StakedStateAddress) {
        self.proposer_count
            .entry(staking_address)
            .and_modify(|count| *count += 1)
            .or_insert(1);
    }

    /// Updates the active validator set information for calculation of `sum_average_stake` used to calculate rewards.
    #[inline]
    pub fn validator_set_changed(&mut self, time: Timespec, active_validator_set: Vec<Validator>) {
        self.validator_set_changes.push((time, active_validator_set))
    }

    /// Calculates the sum of average voting powers of each validator (takes voting power changes in account)
    ///
    /// # Example
    ///
    /// Let us assume that rewards period is 24 hours and there is only one active validator. For the first 23 hours,
    /// their voting power was 50 and for the last hour, their voting power was 100. Then, the sum average stake should
    /// be ((23 * 50) + (1 * 100)) / 24. This should be calculated for each validator and their sum should be returned.
    pub fn get_sum_average_stake(&self) -> Coin {
        todo!()
    }
}
```

### Interactions between Validator Set, Punishments and Rewards Pool

#### Init Chain

- All the structures, `ValidatorSet`, `Punishments`, `RewardsPollState` and `ProposerTracker` should be initialized with
  the values in `genesis.json`.

#### Begin Block

- Proposer tracker should be updated with the staking address of current block's proposer.
- Liveness tracker should be updated with all the signers/non-signers of current block.
- Byzantine validators should be added to punishment queue.
- Non-live validators should be added to punishment queue.
- All the validators in punishment queue should be added to slashing queue (their slash ratio should be updated if
  they're already present in slashing queue).
- If current rewards period is over, then rewards should be distributed and proposer tracker should be re-initialized
  for new rewards period with current active validators.

#### Deliver Transaction

- `NodeJoinTx`
  - After successful validation, add the validator to `power_changed_in_block`.
- `UnbondTx`
  - If the staking address in `UnbondTx` is associated with a validator (i.e., `ValidatorState::get_validator()` returns
    `Some(_)`), then add the new power of validator (power should be zero if remaining stake is less than minimum
    required stake) in `power_changed_in_block`.
- `DepositTx`
  - If the staking address in `UnbondTx` is associated with a validator (i.e., `ValidatorState::get_validator()` returns
    `Some(_)`), then add the new power of validator in `power_changed_in_block`.

#### End Block

- `ValidatorState` should be updated with all the changes in `power_changed_in_block`.
- If there is at least one validator with change in power, `ProposerTracker` should be updated with latest active
  validator set.

## Status

Proposed

## Consequences

### Positive

- This design is more modular and separates concerns of each individual component.
- Having a modular design makes code more comprehensible and easy to modify in future.
- Specified interface for interaction between different components makes it the whole design more robust and less prone
  to bugs.

### Negative

- More code and more abstractions (but I don't thing this should be a concern because Rust compiler should get rid of
  all the unnecessary abstraction in compiled code).

## References

- Fixing [Issue #930](https://github.com/crypto-com/chain/issues/930) is the main motivation behind proposing these
  changes.
