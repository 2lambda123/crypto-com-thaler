# ADR 001: Storage Consolidation

## Changelog
* 10-12-2019: Initial Draft
* 11-12-2019: Extra comments
* 26-12-2019: Add enclave development solution, add design candidates and proposal

## Context
Currently (not counting Tendermint's internal storage or wallets), two processes maintain their internal storage:

* chain-abci: stores the node state, Merkle trie of staking states, transaction metadata (whether spent or not),
validator tracking, etc.
* tx-validation enclave (TVE): sealed transaction data (of valid obfuscated transactions that have outputs)

The reason for having two processes is that SGX SDK compilation is different and needs Intel SGX SDK tooling
(and the subsequent process execution requires Intel SGX PSW tooling, such as AESM service),
so for the development convenience, the transaction validation code that needs to execute in an enclave
is isolated. (For example, one can build and run chain-abci on any platform (e.g. macOS), 
and run the enclave parts inside a docker container or on a remote Linux host.)
The inter-process communication is over a simple REQ-REP 0MQ socket.

*Problem 1: These two storage locations need to be "in sync"*:

when an obfuscated transaction arrives that spends some transaction outputs, chain-abci will do a basic validation and check if they are unspent and forward it to TVE (assuming its storage contains
sealed transaction data of respective outputs). There is currently a naive check that TVE
stores the latest app hash provided by chain-abci; and upon a startup, chain-abci cross-checks if TVE is in sync with it. This leads to various errors and annoyances that are usually resolved by removing all storage and syncing from scratch (in certain cases, there may be a better mechanism, but wasn't implemented).

*Problem 2: Transaction querying*:

As wallet / client-* may be lightweight client and not have access to TEE directly, it will connect to one remotely.
For this purpose, there is transaction query enclave (TQE). See [this document](https://github.com/crypto-com/chain-docs/blob/master/plan.md#transaction-query-enclave-tqe-optional--for-client-infrastructure) for more details.

There are two flows (over an attested secure channel):

1. retrieving transactions: client submits transaction identifiers signed by its view key, and TQE replies with matching transaction data. For this workflow, TQE contacts TVE over REQ-REP 0MQ socket to retrieve data.

2. submitting new transactions: client submits a new transaction, TQE forwards it to TVE that checks it (so that it doesn't obfuscate random / invalid data) and if it's valid, it encrypts it with the obfuscation key (currently compile-time mock, but planned to be periodically regenerated
by another type of enclave) and returns the obfuscated transaction to TQE that forwards it to the client.

In the first flow, TQE only talks to the TVE's application wrapper that handles the persistence -- it can unseal
the transaction data, because the key policy is MRSIGNER. 

In the second flow, TVE holds the obfuscation key inside the enclave memory, so the payload goes to TVE.
Currently, TVE cannot check everything, e.g. staked state or if a transaction output was spent or not
-- in the future, it may internally have app hash components and at least require some lightweight proofs
for these things.

For the first flow, it's unnecessary for TQE to talk to TVE. For the second flow, it'll be desirable
to do a more complete verification (currently there are a few hacks and workarounds).

## Design candidates

### Enclave building and development

Enclave development problem can be solved seperately from storage design.

- Wrap and mock sgx functionality at low level(`sgx-wrapper`crate), keep enclave code runnable both on sgx and non-sgx environments.
- For mocking, `ecall`s can be called like normal function, `ocall`s need more work to mock, if we are embedding `tx-query`.
- Provide two enclave wrapper implementations for each enclave: `sgx` and `mock`, guarded by `mesalock-sgx` and `default` features accordingly. 
  `sgx` enclave wrapper calls enclaves through sgx machanism, `mock` enclave wrapper calls enclave code directly.
- Apps use enclave wrappers as normal.

### Enclave processes design

- Embed `tx-validation` enclave inside `chain-abci`
  (integrate storage, or seperate storage for sealed transaction data?)

  *Positives:*

  - No seperation of storage in different processes
  - No overhead of communications

  *Negatives:*

  - deployment of chain-abci?

- Embed `tx-query` enclave inside `chain-abci`

  provide `tx-query` services in `chain-abci` directly

  *Positives:*

  - No overhead of internal communications

  *Negatives:*

  - Security
  - Scalebility

###  Storage processes design

* Embed storage inside `chain-abci`

  *Positives:*

  * Simple deployment
  * Even simpler if we embed `tx-query` inside `chain-abci`, single process and single storage.

* Seperate storage process

  > Custom grpc service(a la Libra architecture) or relational/no-sql database(Postgres, TiKV)

  *Positives:*

  - More scalable
  - Tools to access and maintain storage if using databases.
  - Good concurrency/transactional/locking support

  *Negatives:*

  - More processes to deploy
  - Overhead to access storage remotely

### `tx-query` design

#### Flow 1: Client encrypt transaction when sending

- Privacy preserving

  Client first send plain text transaction to `tx-query` through attested channel to seal, then send sealed transaction data to `tx-validation` through `abci_query`.

- Non privacy preserving

  Client send plain text transaction to `tx-validation` through `abci_query`.

#### Flow 2: Client retrieving transactions

- Privacy preserving

  Client send txids and view key to `tx-query`through attested channel, `tx-query` get sealed transaction data somehow(through `ocall` or provided by client request), then unseal them. (txids could be leaked by `ocall`, but view key is not)

  `tx-query` has several ways to get sealed transaction data:

  - `tx-query` replicate `chain-abci`storage asynchronously, then access local storage directly.
    - Positives: Best performance
    - Negatives: Needs to implement storage replication, this should be a robust and generic storage replication solution, so there is no data consistency problem we have with seperate storage processes now, either implement with help of low level storage, or implement at application level with custom designed replication log structure.
  - Client fetch sealed transactions through `abci_query`, then pass them to `tx-query` together with view key
    - Positives: Simpler `tx-query` implementation, no `ocall`s
    - Negatives: More client logic, more communication overhead
  - `tx-query` fetch them from `chain-abci` through `abci_query` or `zmq`

- Non privacy preserving

  Client send txids and view key to `chain-abci` through `abci_query`, `chain-abci` load sealed transaction data and request `tx-validation` to unseal them.

## Proposal

Consider simplicy and security, here's proposal for current development stage:

* Embed `tx-validation` enclave inside `chain-abci`
* Provide both privacy preserving and non privacy preserving options, there are many overlappings, so implement both should not be too diffecult. The private full node user can deploy the latter one, so they don't need `tx-query`.
* `tx-query` choose the second method to get sealed transaction data (client retrieve them through `abci_query` in advance)
* `tx-query`APIs, exposed through attested secure channel:
  - `seal_tx(Tx) -> SealedTx`
  - `unseal_tx(Vec<SealedTx>, ViewKey) -> Vec<Tx>`
* `abci_query` APIs:
  - `encrypt_tx_sealed(SealedTx) -> EncryptedTx`
  - `encrypt_tx_plain(Tx) -> EncryptedTx`
  - `unseal_tx(Vec<TxId>, ViewKey) -> Vec<Tx>`
  - `fetch_sealed_tx(Vec<TxId>) -> Vec<SealedTx> `
* `tx-validation` APIs, exposed as `ecall`s:
  - `encrypt_tx_sealed(SealedTx) -> EncryptedTx`
  - `encrypt_tx_plain(Tx) -> EncryptedTx`
  - `unseal_tx(Vec<SealedTx>, ViewKey) -> Vec<Tx>`
* Client supports both privacy perserving and non privacy preserving mode, disable non preserving one by default.
* Keep standalone `tx-query` process to provide attested secure channel.

## Implementation Plan

### Step 1

- Run `tx-validation-app` within `chain-abci`, keep the seperate storage and zmq service, so `tx-query` should be runnabl without further modification.

### Step 2

* Further integrate logic of `tx-validation-app`into `chain-abci`, extract the pure part of logic into `chain-core`.
* Implement the non privacy preserving option:
  - Implement `encrypt_tx_plain`/`unseal_tx` in `chain-abci`
    - deprecate `mockencrypt`/ `mockdecrypt` and `mock-enc-dec` feature guard after this.

### Step 3

* Implement the privacy preserving option:
  - Implement `encrypt_tx_sealed`/`fetch_sealed_tx`in `chain-abci`
  - Refactor `tx-query` as described above, no `ocall`s anymore.

### Step 4

* Implement asynchronous storage replication for `tx-query`

  After this, we can remove `fetch_sealed_tx` from `abci_query`, and `unseal_tx`API of `tx-query` becomes:`unseal_tx(Vec<TxId>, ViewKey) -> Vec<Tx>`.

## Status

Proposed

## References

* moving app wrapers to chain-abci: https://github.com/crypto-com/chain/pull/665#discussion_r356377869
* https://github.com/libra/libra/tree/master/storage/storage-service
